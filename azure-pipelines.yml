# =======================
# Azure Pipelines (Nimbus C#)
# Self-hosted Windows agent
# =======================

trigger:
- main

# ---------- Inputs (shown on "Run pipeline") ----------
parameters:
- name: suiteName
  displayName: Test suite name
  type: string
  default: SampleSmoke

- name: browser
  displayName: Browser
  type: string
  default: chrome
  values: [chrome, edge, firefox]

- name: headless
  displayName: Headless?
  type: boolean
  default: true

- name: groups
  displayName: Categories (comma-separated)
  type: string
  default: smoke,login

- name: threads
  displayName: # of parallel workers
  type: number
  default: 3

- name: gridUrl
  displayName: Selenium Grid URL
  type: string
  default: http://localhost:4444/

# ---------- Variables bridged from parameters ----------
variables:
  SUITE_NAME: ${{ parameters.suiteName }}
  BROWSER:    ${{ parameters.browser }}
  HEADLESS:   ${{ parameters.headless }}
  GROUPS:     ${{ parameters.groups }}
  THREADS:    ${{ parameters.threads }}
  GRID_URL:   ${{ parameters.gridUrl }}

  # Paths
  TEST_PROJ: 'src/Nimbus.Testing/Nimbus.Testing.csproj'
  TRX_DIR:   'target/test-results'
  ALLURE_RESULTS_DIR: 'src/Nimbus.Testing/bin/Release/net9.0/allure-results'

# ---------- Agent pool ----------
pool:
  name: Default
  demands:
    - Agent.OS -equals Windows_NT

# ---------- Pipeline ----------
steps:
- checkout: self

- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '9.0.x'

- powershell: dotnet restore
  displayName: Restore

- powershell: dotnet build --configuration Release --no-restore
  displayName: Build

# # Start Selenoid
# - script: |
#     set -euxo pipefail

#     # Host download dir that your DownloadHelper will watch
#     mkdir -p "$(Build.SourcesDirectory)/selenoid-downloads"
#     chmod 0777 "$(Build.SourcesDirectory)/selenoid-downloads"

#     sudo docker rm -f selenoid || true

#     cat > browsers.json <<'JSON'
#     {
#       "chrome":  { "default": "latest", "versions": { "latest": { "image": "selenoid/chrome:latest",  "port": "4444", "path": "/" } } },
#       "firefox": { "default": "latest", "versions": { "latest": { "image": "selenoid/firefox:latest", "port": "4444", "path": "/" } } },
#       "edge":    { "default": "latest", "versions": { "latest": { "image": "selenoid/edge:latest",    "port": "4444", "path": "/" } } }
#     }
#     JSON

#     case "${BROWSER}" in
#       chrome)  sudo docker pull selenoid/chrome:latest  ;;
#       firefox) sudo docker pull selenoid/firefox:latest ;;
#       edge)    sudo docker pull selenoid/edge:latest    ;;
#       *)       sudo docker pull selenoid/chrome:latest  ;;
#     esac

#     sudo docker run -d --name selenoid -p 4444:4444 \
#       -v "$PWD/browsers.json:/etc/selenoid/browsers.json:ro" \
#       -v /var/run/docker.sock:/var/run/docker.sock \
#       -v "$(Build.SourcesDirectory)/selenoid-downloads:/home/selenium/Downloads" \
#       aerokube/selenoid:latest-release \
#       -limit $(THREADS) -container-network bridge -retry-count 1

#     # quick readiness
#     for i in {1..60}; do
#       curl -sf http://localhost:4444/status >/dev/null && break
#       sleep 2
#     done
#     curl -s http://localhost:4444/status || true
#   displayName: Start Selenoid (limit=$(THREADS))

# Start Selenium Grid locally (Docker Desktop must be running)
- powershell: |
    $ErrorActionPreference = 'Stop'

    # Cleanup hub if exists
    $hub = docker ps -aq -f "name=^selenium-hub$"
    if ($hub) { docker rm -f $hub | Out-Null } else { Write-Host "No existing selenium-hub container." }

    # Cleanup old nodes if any
    $nodes = docker ps -aq --filter "name=selenium-node-"
    if ($nodes) { docker rm -f $nodes | Out-Null } else { Write-Host "No existing selenium-node containers." }

    # Start Hub
    docker run --pull=always -d -p 4444:4444 --name selenium-hub selenium/hub:latest | Out-Null

    # Decide node image based on BROWSER param
    switch ("$(BROWSER)") {
      "chrome"  { $nodeImage = "selenium/node-chrome:latest" }
      "firefox" { $nodeImage = "selenium/node-firefox:latest" }
      "edge"    { $nodeImage = "selenium/node-edge:latest" }
      default   { $nodeImage = "selenium/node-chrome:latest" }
    }

    Write-Host "Starting $(THREADS) $($nodeImage) nodes..."

    # Start N nodes of that browser
    for ($i = 1; $i -le $(THREADS); $i++) {
      docker run -d `
        --name "selenium-node-$i" `
        --link selenium-hub:hub `
        -e SE_EVENT_BUS_HOST=selenium-hub `
        -e SE_EVENT_BUS_PUBLISH_PORT=4442 `
        -e SE_EVENT_BUS_SUBSCRIBE_PORT=4443 `
        $nodeImage | Out-Null
    }

    # Wait until hub is ready
    $ready = $false
    1..30 | ForEach-Object {
      try {
        $r = curl.exe -s http://localhost:4444/status | ConvertFrom-Json
        if ($r.value.ready) { $ready = $true; break }
      } catch {}
      Start-Sleep 2
    }
    if (-not $ready) { throw "Selenium Hub not ready at http://localhost:4444/status" }

    Write-Host "Selenium Hub is up with $(THREADS) nodes for $(BROWSER)."
  displayName: Start Selenium Grid (Hub + Nodes)

# Run tests (edit runsettings XML with your inputs; no fragile quoting)
- powershell: |
    $ErrorActionPreference = 'Stop'

    # Build OR filter like: TestCategory=smoke|TestCategory=login
    $raw = "$(GROUPS)".Replace(" ", "")
    $parts = $raw -split ',' | Where-Object { $_ }
    $filter = ($parts | ForEach-Object { "TestCategory=$_" }) -join '|'

    $runsetPath = 'nimbus.runsettings'
    if (-not (Test-Path $runsetPath)) { throw "Runsettings not found at $runsetPath" }

    # Load runsettings XML
    [xml]$doc = Get-Content -Raw $runsetPath

    # Ensure nodes exist
    $runSettings = $doc.RunSettings
    if (-not $runSettings) { $runSettings = $doc.CreateElement('RunSettings'); $doc.AppendChild($runSettings) | Out-Null }

    $rc = $runSettings.RunConfiguration
    if (-not $rc) { $rc = $doc.CreateElement('RunConfiguration'); $runSettings.AppendChild($rc) | Out-Null }

    $trp = $runSettings.TestRunParameters
    if (-not $trp) { $trp = $doc.CreateElement('TestRunParameters'); $runSettings.AppendChild($trp) | Out-Null }

    $nunit = $runSettings.NUnit
    if (-not $nunit) { $nunit = $doc.CreateElement('NUnit'); $runSettings.AppendChild($nunit) | Out-Null }

    # Helper: set/replace <Parameter name="x" value="y" />
    function Set-Param([System.Xml.XmlElement]$root, [string]$name, [string]$value) {
      $node = $root.SelectSingleNode("Parameter[@name='$name']")
      if (-not $node) {
        $node = $root.OwnerDocument.CreateElement('Parameter')
        $node.SetAttribute('name', $name)
        $root.AppendChild($node) | Out-Null
      }
      $node.SetAttribute('value', $value)
    }

    # Map pipeline variables to runsettings (lowercase boolean for headless)
    $suiteName = "$(SUITE_NAME)"
    $browser   = "$(BROWSER)"
    $headless  = "$(HEADLESS)"; $headless = ($headless -as [string]).ToLower()
    $remote    = "true"
    $gridUrl   = "$(GRID_URL)"
    $threads   = "$(THREADS)"

    Set-Param $trp 'testSuiteName' $suiteName
    Set-Param $trp 'browser'      $browser
    Set-Param $trp 'headless'     $headless
    Set-Param $trp 'remote'       $remote
    Set-Param $trp 'gridUrl'      $gridUrl

    # Robust: ensure/replace <NumberOfTestWorkers>
    $workersNode = $nunit.SelectSingleNode('NumberOfTestWorkers')
    if (-not $workersNode) {
      $workersNode = $doc.CreateElement('NumberOfTestWorkers')
      $nunit.AppendChild($workersNode) | Out-Null
    }
    $workersNode.InnerText = [string]$threads

    # Robust: ensure/replace/remove <TestCaseFilter>
    $filterNode = $rc.SelectSingleNode('TestCaseFilter')
    if ($filter) {
      if (-not $filterNode) {
        $filterNode = $doc.CreateElement('TestCaseFilter')
        $rc.AppendChild($filterNode) | Out-Null
      }
      $filterNode.InnerText = $filter
    } else {
      if ($filterNode) { $rc.RemoveChild($filterNode) | Out-Null }
    }

    $doc.Save($runsetPath)

    # Ensure results dir exists
    $trxDir = '$(TRX_DIR)'
    New-Item -ItemType Directory -Force -Path $trxDir | Out-Null

    # Run tests
    & dotnet test `
      --configuration Release `
      --no-build `
      --logger "trx;LogFileName=test_results.trx" `
      --results-directory $trxDir `
      --settings $runsetPath `
      "$(TEST_PROJ)"
    $code = $LASTEXITCODE

    # --- Decide pass/fail semantics ---
    # If dotnet returned non-zero, decide whether it's JUST test failures or an infra/build error.
    if ($code -ne 0) {
      # Find newest TRX (if any)
      $trx = Get-ChildItem -Path $trxDir -Recurse -Filter *.trx -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if ($trx) {
        try {
          [xml]$x = Get-Content -Raw $trx.FullName
          $sum = $x.TestRun.ResultSummary
          $cnt = $sum.Counters
          $total  = [int]$cnt.total
          $passed = [int]$cnt.passed
          $failed = [int]$cnt.failed
          $skipped= [int]$cnt.notExecuted
          $outcome = [string]$sum.outcome

          # If we executed tests and have failures, treat as test failures (not infra)
          if ($total -gt 0 -and ($failed -gt 0 -or $outcome -in @('Failed','Completed'))) {
            Write-Host "##vso[task.issue type=warning]$failed test(s) failed (total=$total, passed=$passed, skipped=$skipped). Marking step as SucceededWithIssues."
            Write-Host "##vso[task.complete result=SucceededWithIssues;]"
            exit 0
          }
        } catch {
          # Fall through to infra error if TRX couldn't be parsed
        }
      }
      # No TRX or no tests => infra/build error, keep failing
      exit $code
    }

    # dotnet exit code was 0 => success
    exit 0
  displayName: Run Nimbus tests

# Publish TRX to Tests tab
- task: PublishTestResults@2
  condition: always()
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '$(TRX_DIR)/**/*.trx'
    failTaskOnFailedTests: false
  displayName: Publish TRX

# Allure (uses the Azure DevOps extension)
- task: PublishAllureReport@1
  displayName: "Publish Allure report"
  condition: always()
  inputs:
    testResultsDir: "$(ALLURE_RESULTS_DIR)"
    reportName: "Nimbus â€“ $(Build.BuildNumber)"

# Cleanup Selenium container
- powershell: |
    try { docker rm -f selenium-grid | Out-Null } catch { Write-Host "Already gone (ok)." }
  displayName: Stop Selenium Grid
  condition: always()