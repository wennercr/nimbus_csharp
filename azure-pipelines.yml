# =======================
# Azure Pipelines (Nimbus C#)
# Self-hosted Windows agent
# =======================

trigger:
- main

# ---------- Inputs (shown on "Run pipeline") ----------
parameters:
- name: suiteName
  displayName: Test suite name
  type: string
  default: SampleSmoke

- name: browser
  displayName: Browser
  type: string
  default: chrome
  values: [chrome, edge, firefox]

- name: headless
  displayName: Headless?
  type: boolean
  default: true

- name: groups
  displayName: Categories (comma-separated)
  type: string
  default: smoke,login

- name: threads
  displayName: # of parallel workers
  type: number
  default: 3

- name: gridUrl
  displayName: Selenium Grid URL
  type: string
  default: http://localhost:4444/wd/hub

# ---------- Variables bridged from parameters ----------
variables:
  SUITE_NAME: ${{ parameters.suiteName }}
  BROWSER:    ${{ parameters.browser }}
  HEADLESS:   ${{ parameters.headless }}
  GROUPS:     ${{ parameters.groups }}
  THREADS:    ${{ parameters.threads }}
  GRID_URL:   ${{ parameters.gridUrl }}

  # Paths
  TEST_PROJ: 'src/Nimbus.Testing/Nimbus.Testing.csproj'
  TRX_DIR:   'target/test-results'
  ALLURE_RESULTS_DIR: 'src/Nimbus.Testing/bin/Release/net9.0/allure-results'

# ---------- Agent pool ----------
pool:
  name: Default
  demands:
    - Agent.OS -equals Windows_NT

# ---------- Pipeline ----------
steps:
- checkout: self

- task: UseDotNet@2
  inputs:
    packageType: 'sdk'
    version: '9.0.x'

- powershell: dotnet restore
  displayName: Restore

- powershell: dotnet build --configuration Release --no-restore
  displayName: Build

# Start Selenium Grid locally (Docker Desktop must be running)
# - powershell: |
#     $ErrorActionPreference = 'Stop'

#     $existing = docker ps -aq -f "name=^selenium-grid$"
#     if ($existing) { docker rm -f selenium-grid | Out-Null }

#     docker run --pull=always -d -p 4444:4444 --shm-size=2g --name selenium-grid selenium/standalone-chrome:latest | Out-Null

#     # readiness check
#     $ready = $false
#     1..30 | ForEach-Object {
#       try { $r = curl.exe -s http://localhost:4444/status | ConvertFrom-Json; if ($r.value.ready) { $ready = $true; break } } catch {}
#       Start-Sleep 2
#     }
#     if (-not $ready) { throw "Selenium Grid not ready at http://localhost:4444/status" }
#   displayName: Start Selenium Grid

# --- Start Selenoid (auto browsers, parallel by limit) ---
- powershell: |
    $ErrorActionPreference = 'Stop'

    # Detect Docker named pipe on Windows
    $candidates = @('\\.\pipe\docker_engine','\\.\pipe\dockerDesktopEngine')
    $pipe = $candidates | Where-Object { Test-Path $_ } | Select-Object -First 1
    if (-not $pipe) {
      Write-Error "Could not find a Docker Desktop named pipe. Is Docker Desktop running?"
    }

    Write-Host "Using Docker pipe: $pipe"

    # Clean any old Selenoid container
    docker rm -f selenoid 2>$null | Out-Null

    # Write browsers.json (UTF-8 **no BOM**)
    $browsersJson = @'
    {
      "chrome":  { "default": "latest", "versions": { "latest": { "image":"selenoid/chrome:latest",  "port":"4444", "path":"/" } } },
      "firefox": { "default": "latest", "versions": { "latest": { "image":"selenoid/firefox:latest", "port":"4444", "path":"/" } } },
      "edge":    { "default": "latest", "versions": { "latest": { "image":"selenoid/edge:latest",    "port":"4444", "path":"/" } } }
    }
    '@
        $browsersPath = Join-Path -Path "$(Build.SourcesDirectory)" -ChildPath "browsers.json"
        $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
        [System.IO.File]::WriteAllText($browsersPath, $browsersJson, $utf8NoBom)
        Write-Host "browsers.json written to: $browsersPath"

        # Optional: pre-pull only the browser you’re going to use
        switch ("$(BROWSER)") {
          "chrome"  { docker pull selenoid/chrome:latest  | Out-Host }
          "firefox" { docker pull selenoid/firefox:latest | Out-Host }
          "edge"    { docker pull selenoid/edge:latest    | Out-Host }
          default   { docker pull selenoid/chrome:latest  | Out-Host }
        }

        # Build docker-host for Selenoid based on the detected pipe
        $dockerHost =
          if ($pipe -like '*docker_engine') { 'npipe:////./pipe/docker_engine' }
          else { 'npipe:////./pipe/dockerDesktopEngine' }

        # Run Selenoid. Note: --mount with the named pipe **and** browsers.json.
        $run = @(
          'run','-d','--name','selenoid',
          '-p','4444:4444',
          '--mount',"type=bind,source=$pipe,target=$pipe",
          '--mount',"type=bind,source=$browsersPath,target=/etc/selenoid/browsers.json,readonly",
          'aerokube/selenoid:latest-release',
          '-limit', "$(THREADS)",
          '-conf', '/etc/selenoid/browsers.json',
          '-docker-host', $dockerHost,
          '-retry-count','1'
        )
        Write-Host "docker $($run -join ' ')"
        docker @run | Out-Host

        # Soft readiness check (don’t fail the job here)
        $ready = $false
        foreach ($i in 1..20) {
          try {
            $r = Invoke-RestMethod -Method GET -Uri 'http://localhost:4444/status' -TimeoutSec 2
            if ($r -and $r.state -eq 'ready') { $ready = $true; break }
          } catch {}
          Start-Sleep -Seconds 2
        }
        if (-not $ready) {
          Write-Warning "Selenoid not yet ready; continuing. Current logs:"
          docker logs selenoid 2>&1 | Out-Host
        } else {
          Write-Host "Selenoid is ready:"
          Invoke-RestMethod http://localhost:4444/status | ConvertTo-Json -Depth 6
        }
  displayName: Start Selenoid (auto browsers, parallel by limit)






# Run tests (edit runsettings XML with your inputs; no fragile quoting)
- powershell: |
    $ErrorActionPreference = 'Stop'

    # Build OR filter like: TestCategory=smoke|TestCategory=login
    $raw = "$(GROUPS)".Replace(" ", "")
    $parts = $raw -split ',' | Where-Object { $_ }
    $filter = ($parts | ForEach-Object { "TestCategory=$_" }) -join '|'

    $runsetPath = 'nimbus.runsettings'
    if (-not (Test-Path $runsetPath)) { throw "Runsettings not found at $runsetPath" }

    # Load runsettings XML
    [xml]$doc = Get-Content -Raw $runsetPath

    # Ensure nodes exist
    $runSettings = $doc.RunSettings
    if (-not $runSettings) { $runSettings = $doc.CreateElement('RunSettings'); $doc.AppendChild($runSettings) | Out-Null }

    $rc = $runSettings.RunConfiguration
    if (-not $rc) { $rc = $doc.CreateElement('RunConfiguration'); $runSettings.AppendChild($rc) | Out-Null }

    $trp = $runSettings.TestRunParameters
    if (-not $trp) { $trp = $doc.CreateElement('TestRunParameters'); $runSettings.AppendChild($trp) | Out-Null }

    $nunit = $runSettings.NUnit
    if (-not $nunit) { $nunit = $doc.CreateElement('NUnit'); $runSettings.AppendChild($nunit) | Out-Null }

    # Helper: set/replace <Parameter name="x" value="y" />
    function Set-Param([System.Xml.XmlElement]$root, [string]$name, [string]$value) {
      $node = $root.SelectSingleNode("Parameter[@name='$name']")
      if (-not $node) {
        $node = $root.OwnerDocument.CreateElement('Parameter')
        $node.SetAttribute('name', $name)
        $root.AppendChild($node) | Out-Null
      }
      $node.SetAttribute('value', $value)
    }

    # Map pipeline variables to runsettings (lowercase boolean for headless)
    $suiteName = "$(SUITE_NAME)"
    $browser   = "$(BROWSER)"
    $headless  = "$(HEADLESS)"; $headless = ($headless -as [string]).ToLower()
    $remote    = "true"
    $gridUrl   = "$(GRID_URL)"
    $threads   = "$(THREADS)"

    Set-Param $trp 'testSuiteName' $suiteName
    Set-Param $trp 'browser'      $browser
    Set-Param $trp 'headless'     $headless
    Set-Param $trp 'remote'       $remote
    Set-Param $trp 'gridUrl'      $gridUrl

    # Robust: ensure/replace <NumberOfTestWorkers>
    $workersNode = $nunit.SelectSingleNode('NumberOfTestWorkers')
    if (-not $workersNode) {
      $workersNode = $doc.CreateElement('NumberOfTestWorkers')
      $nunit.AppendChild($workersNode) | Out-Null
    }
    $workersNode.InnerText = [string]$threads

    # Robust: ensure/replace/remove <TestCaseFilter>
    $filterNode = $rc.SelectSingleNode('TestCaseFilter')
    if ($filter) {
      if (-not $filterNode) {
        $filterNode = $doc.CreateElement('TestCaseFilter')
        $rc.AppendChild($filterNode) | Out-Null
      }
      $filterNode.InnerText = $filter
    } else {
      if ($filterNode) { $rc.RemoveChild($filterNode) | Out-Null }
    }

    $doc.Save($runsetPath)

    # Ensure results dir exists
    $trxDir = '$(TRX_DIR)'
    New-Item -ItemType Directory -Force -Path $trxDir | Out-Null

    # Run tests
    & dotnet test `
      --configuration Release `
      --no-build `
      --logger "trx;LogFileName=test_results.trx" `
      --results-directory $trxDir `
      --settings $runsetPath `
      "$(TEST_PROJ)"
    $code = $LASTEXITCODE

    # --- Decide pass/fail semantics ---
    # If dotnet returned non-zero, decide whether it's JUST test failures or an infra/build error.
    if ($code -ne 0) {
      # Find newest TRX (if any)
      $trx = Get-ChildItem -Path $trxDir -Recurse -Filter *.trx -ErrorAction SilentlyContinue | Sort-Object LastWriteTime -Descending | Select-Object -First 1
      if ($trx) {
        try {
          [xml]$x = Get-Content -Raw $trx.FullName
          $sum = $x.TestRun.ResultSummary
          $cnt = $sum.Counters
          $total  = [int]$cnt.total
          $passed = [int]$cnt.passed
          $failed = [int]$cnt.failed
          $skipped= [int]$cnt.notExecuted
          $outcome = [string]$sum.outcome

          # If we executed tests and have failures, treat as test failures (not infra)
          if ($total -gt 0 -and ($failed -gt 0 -or $outcome -in @('Failed','Completed'))) {
            Write-Host "##vso[task.issue type=warning]$failed test(s) failed (total=$total, passed=$passed, skipped=$skipped). Marking step as SucceededWithIssues."
            Write-Host "##vso[task.complete result=SucceededWithIssues;]"
            exit 0
          }
        } catch {
          # Fall through to infra error if TRX couldn't be parsed
        }
      }
      # No TRX or no tests => infra/build error, keep failing
      exit $code
    }

    # dotnet exit code was 0 => success
    exit 0
  displayName: Run Nimbus tests

# Publish TRX to Tests tab
- task: PublishTestResults@2
  condition: always()
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '$(TRX_DIR)/**/*.trx'
    failTaskOnFailedTests: false
  displayName: Publish TRX

# Allure (uses the Azure DevOps extension)
- task: PublishAllureReport@1
  displayName: "Publish Allure report"
  condition: always()
  inputs:
    testResultsDir: "$(ALLURE_RESULTS_DIR)"
    reportName: "Nimbus – $(Build.BuildNumber)"

# Cleanup Selenium container
- powershell: docker rm -f selenium-grid 2>$null
  displayName: Stop Selenium Grid
  condition: always()